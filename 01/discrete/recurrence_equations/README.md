УКРАЇНСЬКИЙ КАТОЛИЦЬКИЙ УНІВЕРСИТЕТ
ФАКУЛЬТЕТ ПРИКЛАДНИХ НАУК
IT та Бізнес-аналітика 
Комп’ютерні науки

Аналіз рекурентних рівнянь

Автори:
Олексюк Любомир
Скоропад Мар’яна
Демчук Назар
Пеняга Назарій
Шуляр Владислав 

21 грудня 2021

1.   Вступ. 
План проекту був поділений на підчастини. Кожен учасник взяв на себе певну частину роботи для реалізації проекту.
1) Скоропад Мар’яна розробила функції, які сприймають інпути від користувача і перевіряють правильність вводів, внесла свою лепту в оформлення виводів для користувача. Допомагала з розробкою і наповненням презентації. 
2) Демчук Назар розробив функції, які вирішують систему лінійних рівнянь і знаходять коефіцієнти, які необхідні для загального запису рекурентного рівняння, склав загальний запис рівняння. Вніс свою лепту в оформлення коду для користувача.
3) Пеняга Назарій розробив функції, які працюють із рівняннями, знаходять їхні дійсні корені. Для цього було використано numpy. Контролював та виправляв код згідно до стилю PEP 08.
4) Олексюк Любомир дослідив методи розробки алгоритму, що знаходив б n-ий член за логарифмічний час. Для цього було використано знання множення матриць, а також аналіз даних рекурентного рівняння (перші n-членів і коефіцієнти біля них) для обчислення n-ого члену послідовності.
5) Шуляр Владислав реалізував функції для обрахування тривалості виконання обчислень програми і для обчислення n-ного члена рівняння. Організував роботу з сервісом Github, Google CoLab. Розробляв презентацію для презентування проєкту.
 
2.   Псевдокод.
1.Початкові функції спрямовані на те, щоб користувач ознайомився з форматом вводу і ввів основні дані, які потім будуть передані в наступні функції для розв’язку і виконання поставленого завдання.
Функція main_info_start() - представлення програми, виводить інформацію про правильний ввід коефіцієнтів.
Функція variables(inputfunct = input)-приймає від користувача коефіцієнти, повертає список з булевими значеннями, які відповідають тому, чи кожний елемент, введений користувачем, є числом, і сам список зі значеннями.
Функція conduct_eq(coeffslst)- приймає коефіцієнти, повертає макет рекурентного рівняння, який висвітлюється користувачу.
Функція input_coeffs_inits()- використовує функції variables() і conduct_eq(coeffslst)) для того, щоб перевірити правильність вводу коефіцієнтів, чи те рівняння хоче розв’язати користувач і повертає списки з коефіцієнтів і початкових значень.
​​Функція correct_roots(roots, epsilon=0.001) - коректує корені рівняння, заокруглючи їх до більшого числа, якщо різниця між числом і його заокругленим варіантом є меншою за епсилон. Повертає список з коренями рівняння.
Функція solve_lianalg_system(roots, initials) - функція приймає корені характеристичного рівняння і за допомогою модуля нампай вирішує систему рівнянь і знаходить коефіцієнти при коренях. Повертає список з коефіцієнтів.
Функція get_general_view(roots, initials) - приймає корені характеристичного рівняння і початкові значення, повертає загальний вигляд формули рекуретного рівняння.
​​Функція solve_equation(coeffs: list) - це функція, яка приймає список з коефіцієнтів, які знаходяться біля змінних у рівнянні. За допомогою Numpy ми можемо знайти корені рівнянь. Numpy повертає список із комплексними числами і для цього ми створюємо функцію real_roots(roots: list, min_grade=-1.32). Вивід програми: список із коренів рівняння.
Функція real_roots(roots: list, min_grade=-1.32) - функція, яка працює із комплексними коренями рівняння. Відкидає комплексну частину, якщо вона менша ніж min_grade(був підібраний методом підбору(максимально точно)). Викликає функцію correct_roots(roots, epsilon=0.001). Повертає дійсні корені.
Функція log_calculation() відповідала за обчислення рекурентних рівнянь за логарифмічний час. Для цього створюється дві матриці. Перший рядок першої матриці (М)- це коефіцієнти біля перших n членів послідовність. В наступних рядках ми записуємо одинички по діагоналі, останній рядок видаляєм. Інша матриця (А0)- це рядок перших n членів послідовності, даних умовою. Тоді при перемноженні цих матриць ми отримуємо матрицю (А1), яка містить перших n + 1 членів, але вже без останнього. Тобто матриця членів зсувається на один член вверх при кожному перемноженні. Таким чином, виведено формулу, що (М^ n) * A0 = An.
Потім з матриці Аn дістаємо необхідний нам член. Щоб реалізувати цю формулу необхідно створити матрицю М, використовуючи цикл складністю в кількість перших даних членів. Потім, за допомогою функції matrix_power, піднесемо М в необхідний степінь за логарифмічний час. Для цього використаємо метод ділення степеня на два, якщо степень парний то ділимо на два і виконуємо функцію для нього, після чого множимо само на себе. Якщо степінь непарний, то виконуємо функцію для степіня на один меншого. І якщо степінь дорівнює 1, то повертаємо матрицю. Таким чином, рекурсивно запускаючи функцію для нового степеня, отримуємо матрицю в степені n, за час log(n). 

3.   Висновки.
Результатом нашої роботи є програма, що здатна вирішувати однорідні рекурентні рівняння та знаходити н-ний член послідовності через розв’язок рекурентного рівняння та методу множення матриць. Наша програма розв’язує рекурентні рівняння, які мають дуже широке коло застосування у теорії алгоритмів, інформатиці, різних розділах математики. Ми дослідили способи знаходження розв’язків рекурентних рівнянь. Наша програма здатна знайти певний розв’язок рекурентного рівняння за початковими вхідними даними.
